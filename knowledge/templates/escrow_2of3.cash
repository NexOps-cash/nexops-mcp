pragma cashscript ^0.13.0;

// CONTRACT TYPE: 2-of-3 Escrow
// USE CASE: Buyer–Seller escrow with arbiter dispute resolution
// SECURITY LEVEL: High
// DESIGN GOAL: Explicit correctness, adversarial safety, audit clarity

// ROLES:
// - buyer: Provides funds, receives goods/services, can refund after timeout
// - seller: Provides goods/services, receives payment on successful delivery
// - arbiter: Neutral third party for dispute resolution

// SPENDING PATHS:
// 1. Normal settlement: buyer + seller agree (any time)
// 2. Dispute resolution: buyer + arbiter agree (any time)
// 3. Dispute resolution: seller + arbiter agree (any time)
// 4. Timeout refund: buyer alone after refundTimeout expires

// EXPLICIT DESIGN DECISIONS:
// - This contract intentionally does NOT support arbiter-only spending
// - Buyer MAY redirect refund to any script (intentional flexibility)
// - This contract does NOT handle CashTokens (BCH-only)
// - This escrow enforces BCH-only outputs
// - CashTokens are intentionally rejected to eliminate token-layer attack surfaces

contract Escrow2of3(
    pubkey buyer,
    pubkey seller,
    pubkey arbiter,
    int refundTimeout  // Absolute block time (median time past) for buyer refund
) {
    // NORMAL SETTLEMENT PATH
    // Both buyer and seller agree on the outcome
    // This is the expected happy path for successful transactions
    function settle(sig buyerSig, sig sellerSig, bytes recipientLockingBytecode, int amount) {
        // TOKEN CATEGORY CONSTANT
        // bytes32 representation of "no token" for explicit validation
        bytes32 NO_TOKEN = 0x0000000000000000000000000000000000000000000000000000000000000000;

        // ACTIVE INPUT VALIDATION
        // Verify that THIS contract is the input being spent
        // Prevents UTXO position attacks where attacker places contract at wrong index
        require(tx.inputs[this.activeInputIndex].lockingBytecode == this.lockingBytecode);

        // INPUT TOKEN VALIDATION
        // Prevent tokenized UTXO from being locked in this contract
        // This is a defensive measure to avoid token-layer confusion
        require(tx.inputs[this.activeInputIndex].tokenCategory == NO_TOKEN);

        // VALUE BOUNDARY VALIDATION
        // Ensure settlement amount does not exceed available input value
        // This is NOT a fee assumption - this is value sanity enforcement
        int inputValue = tx.inputs[this.activeInputIndex].value;
        require(amount <= inputValue);

        // SIGNATURE VALIDATION
        // Verify buyer signature explicitly (no shorthand)
        require(checkSig(buyerSig, buyer));
        
        // Verify seller signature explicitly (no shorthand)
        require(checkSig(sellerSig, seller));

        // OUTPUT VALIDATION
        // Require exactly one output to prevent output manipulation attacks
        // Without this check, attacker could add additional outputs draining funds
        require(tx.outputs.length == 1);

        // SEMANTIC OUTPUT VALIDATION
        // Verify the output sends to the intended recipient
        // This prevents signature replay to unauthorized addresses
        require(tx.outputs[0].lockingBytecode == recipientLockingBytecode);

        // AMOUNT VALIDATION
        // Verify the output amount matches the agreed settlement amount
        // This ensures the full intended amount is transferred
        // The difference (inputValue - amount) becomes the mining fee
        require(tx.outputs[0].value == amount);

        // OUTPUT TOKEN VALIDATION
        // Prevent unexpected CashToken attachment to output
        // This contract is BCH-only and does not handle tokens
        require(tx.outputs[0].tokenCategory == NO_TOKEN);

        // SECURITY NOTE: We do NOT assume any specific recipient (could be buyer, seller, or split)
    }

    // DISPUTE RESOLUTION PATH: BUYER + ARBITER
    // Buyer and arbiter agree (typically refund scenario)
    function disputeBuyerArbiter(sig buyerSig, sig arbiterSig, bytes recipientLockingBytecode, int amount) {
        // TOKEN CATEGORY CONSTANT
        bytes32 NO_TOKEN = 0x0000000000000000000000000000000000000000000000000000000000000000;

        // ACTIVE INPUT VALIDATION
        // Verify that THIS contract is the input being spent
        require(tx.inputs[this.activeInputIndex].lockingBytecode == this.lockingBytecode);

        // INPUT TOKEN VALIDATION
        // Prevent tokenized UTXO from being locked in this contract
        require(tx.inputs[this.activeInputIndex].tokenCategory == NO_TOKEN);

        // VALUE BOUNDARY VALIDATION
        // Ensure dispute resolution amount does not exceed available input value
        int inputValue = tx.inputs[this.activeInputIndex].value;
        require(amount <= inputValue);

        // SIGNATURE VALIDATION
        // Verify buyer signature explicitly
        require(checkSig(buyerSig, buyer));
        
        // Verify arbiter signature explicitly
        require(checkSig(arbiterSig, arbiter));

        // OUTPUT VALIDATION
        // Require exactly one output to prevent output manipulation
        require(tx.outputs.length == 1);

        // SEMANTIC OUTPUT VALIDATION
        // Verify the output sends to the intended recipient
        require(tx.outputs[0].lockingBytecode == recipientLockingBytecode);

        // AMOUNT VALIDATION
        // Verify the output amount matches the agreed dispute resolution amount
        require(tx.outputs[0].value == amount);

        // OUTPUT TOKEN VALIDATION
        // Prevent unexpected CashToken attachment to output
        require(tx.outputs[0].tokenCategory == NO_TOKEN);
    }

    // DISPUTE RESOLUTION PATH: SELLER + ARBITER
    // Seller and arbiter agree (typically payout scenario)
    function disputeSellerArbiter(sig sellerSig, sig arbiterSig, bytes recipientLockingBytecode, int amount) {
        // TOKEN CATEGORY CONSTANT
        bytes32 NO_TOKEN = 0x0000000000000000000000000000000000000000000000000000000000000000;

        // ACTIVE INPUT VALIDATION
        // Verify that THIS contract is the input being spent
        require(tx.inputs[this.activeInputIndex].lockingBytecode == this.lockingBytecode);

        // INPUT TOKEN VALIDATION
        // Prevent tokenized UTXO from being locked in this contract
        require(tx.inputs[this.activeInputIndex].tokenCategory == NO_TOKEN);

        // VALUE BOUNDARY VALIDATION
        // Ensure dispute resolution amount does not exceed available input value
        int inputValue = tx.inputs[this.activeInputIndex].value;
        require(amount <= inputValue);

        // SIGNATURE VALIDATION
        // Verify seller signature explicitly
        require(checkSig(sellerSig, seller));
        
        // Verify arbiter signature explicitly
        require(checkSig(arbiterSig, arbiter));

        // OUTPUT VALIDATION
        // Require exactly one output to prevent output manipulation
        require(tx.outputs.length == 1);

        // SEMANTIC OUTPUT VALIDATION
        // Verify the output sends to the intended recipient
        require(tx.outputs[0].lockingBytecode == recipientLockingBytecode);

        // AMOUNT VALIDATION
        // Verify the output amount matches the agreed dispute resolution amount
        require(tx.outputs[0].value == amount);

        // OUTPUT TOKEN VALIDATION
        // Prevent unexpected CashToken attachment to output
        require(tx.outputs[0].tokenCategory == NO_TOKEN);
    }

    // TIMEOUT REFUND PATH
    // Buyer can reclaim funds if seller is unresponsive after timeout
    // This protects buyer from seller abandonment
    function refund(sig buyerSig, bytes buyerRefundLockingBytecode, int refundAmount) {
        // TOKEN CATEGORY CONSTANT
        bytes32 NO_TOKEN = 0x0000000000000000000000000000000000000000000000000000000000000000;

        // TIMELOCK VALIDATION
        // tx.time represents the current block's median time past (MTP)
        // It is consensus-derived and NOT user-controlled
        // Use >= operator (never >) for time comparisons to match consensus rules
        // This must be >= refundTimeout for the refund to be valid
        require(tx.time >= refundTimeout);

        // ACTIVE INPUT VALIDATION
        // Verify that THIS contract is the input being spent
        require(tx.inputs[this.activeInputIndex].lockingBytecode == this.lockingBytecode);

        // INPUT TOKEN VALIDATION
        // Prevent tokenized UTXO from being locked in this contract
        require(tx.inputs[this.activeInputIndex].tokenCategory == NO_TOKEN);

        // VALUE BOUNDARY VALIDATION
        // Ensure refund amount does not exceed available input value
        int inputValue = tx.inputs[this.activeInputIndex].value;
        require(refundAmount <= inputValue);

        // SIGNATURE VALIDATION
        // Verify buyer signature explicitly
        // Only the buyer can claim refund (unilateral after timeout)
        require(checkSig(buyerSig, buyer));

        // OUTPUT VALIDATION
        // Require exactly one output to prevent output manipulation
        require(tx.outputs.length == 1);

        // SEMANTIC OUTPUT VALIDATION
        // Verify the refund goes to buyer's specified address
        // INTENTIONAL DESIGN: Buyer MAY redirect refund to any script they control
        // This is NOT a vulnerability - it provides legitimate flexibility
        // Buyer can refund to a different address, multisig, or covenant as needed
        require(tx.outputs[0].lockingBytecode == buyerRefundLockingBytecode);

        // AMOUNT VALIDATION
        // Verify the refund amount is as specified
        // Buyer can choose to take less (leaving more for fees) but not more
        require(tx.outputs[0].value == refundAmount);

        // OUTPUT TOKEN VALIDATION
        // Prevent unexpected CashToken attachment to output
        require(tx.outputs[0].tokenCategory == NO_TOKEN);

        // SECURITY NOTE: refundTimeout must be set to a future time when contract is created
        // SECURITY NOTE: Buyer must wait until block time >= refundTimeout
        // SECURITY NOTE: Transaction nLocktime must be set to a value >= refundTimeout
    }
}

// DEPLOYMENT NOTES:
// - Set refundTimeout to a reasonable future time (e.g., current time + 30 days)
// - Use median time past (MTP) for time calculations, not block header time
// - All three parties should verify contract parameters before funding
// - Buyer funds the contract after all parties agree on parameters
// - Mining fees are implicit: inputValue - outputValue = fee
// - Always verify recipientLockingBytecode matches intended recipient's address

// SECURITY INVARIANTS:
// ✓ Explicit activeInputIndex validation on all paths
// ✓ Explicit input tokenCategory validation on all paths
// ✓ Explicit amount ≤ inputValue validation on all paths
// ✓ No implicit output ordering assumptions
// ✓ Explicit tx.outputs.length validation on all paths
// ✓ Explicit lockingBytecode validation on all paths
// ✓ Explicit amount validation on all paths
// ✓ Explicit signature validation (no checkMultiSig shorthand)
// ✓ Timelock uses >= operator (consensus-compliant)
// ✓ Explicit output token category validation (NO_TOKEN)
// ✓ No fee assumptions (caller specifies output amount)
// ✓ No hidden state or side effects
// ✓ Adversarial transaction builder cannot bypass validations

// AUDIT CHECKLIST:
// [ ] Verify all paths validate activeInputIndex
// [ ] Verify all paths validate input tokenCategory == NO_TOKEN
// [ ] Verify all paths validate amount ≤ inputValue
// [ ] Verify all signature checks use explicit checkSig
// [ ] Verify all paths validate tx.outputs.length == 1
// [ ] Verify all paths validate lockingBytecode semantically
// [ ] Verify all paths validate output amount
// [ ] Verify all paths validate output tokenCategory == NO_TOKEN
// [ ] Verify timeout path uses >= operator for tx.time
// [ ] Verify no implicit assumptions about fees or recipients
// [ ] Verify contract parameters are immutable
// [ ] Test each spending path independently
// [ ] Verify transaction builder cannot add unauthorized outputs
// [ ] Verify no signature reuse across different spending paths
// [ ] Verify no arbiter-only spending path exists
// [ ] Verify tx.time comment correctly describes MTP (not nLocktime)