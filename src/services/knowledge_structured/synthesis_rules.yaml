# Synthesis rules — always injected. High-level structural patterns for contract generation.
# These are intent-level constraints with canonical code shapes to reduce LLM drift.

multisig:
  rules:
    - id: MULTISIG-DISTINCT-KEYS
      rule: "All pubkeys in a multisig MUST be distinct. Add require(pk1 != pk2) for every pair."
    - id: MULTISIG-DISTINCT-SIGS
      rule: "Use distinct signature variable names per signer (aliceSig, bobSig, carolSig)."
    - id: MULTISIG-THRESHOLD
      rule: "Implement threshold using integer accumulation of checkSig() results, not nested AND/OR chains."

  canonical_2_of_3:
    description: "Standard 2-of-3 multisig pattern. Use integer accumulation, not nested booleans."
    shape: |
      int valid =
          (checkSig(sig1, pk1) ? 1 : 0) +
          (checkSig(sig2, pk2) ? 1 : 0) +
          (checkSig(sig3, pk3) ? 1 : 0);
      require(valid >= 2);
    notes:
      - "Do NOT require a specific signer — any 2 of 3 must be valid."
      - "Do NOT use nested AND/OR chains like checkSig(a,A) && (checkSig(b,B) || checkSig(c,C))."
      - "Distinctness checks: require(pk1 != pk2); require(pk1 != pk3); require(pk2 != pk3);"

  canonical_2_of_2:
    description: "Standard 2-of-2 multisig pattern with output anchoring."
    shape: |
      require(pk1 != pk2);
      require(tx.outputs.length == 1);
      require(tx.outputs[0].value == tx.inputs[this.activeInputIndex].value);
      require(checkSig(sig1, pk1));
      require(checkSig(sig2, pk2));
    notes:
      - "Output count MUST be validated to prevent extra outputs draining funds."
      - "Output value MUST equal input value — no implicit fee arithmetic."

  canonical_split_2party:
    description: "Canonical 2-party split. EXACTLY two outputs, deterministic ordering."
    shape: |
      require(pk1 != pk2);
      require(tx.outputs.length == 2);

      // Deterministic output ordering
      require(tx.outputs[0].lockingBytecode == pk1);
      require(tx.outputs[1].lockingBytecode == pk2);

      // Explicit position validation before value use
      require(tx.outputs[0].value >= 0);
      require(tx.outputs[1].value >= 0);

      // Conservation invariant
      require(
          tx.outputs[0].value + tx.outputs[1].value ==
          tx.inputs[this.activeInputIndex].value
      );

      require(checkSig(sig1, pk1));
      require(checkSig(sig2, pk2));
    notes:
      - "Output order is FIXED: index 0 → pk1, index 1 → pk2."
      - "Do NOT infer output ordering dynamically."
      - "Do NOT use division unless divisor validated > 0."
      - "No loops. No iteration over outputs."

timelock:
  rules:
    - id: TIMELOCK-GTE
      rule: "Use tx.time >= deadline for absolute timelocks (CLTV). NEVER use tx.inputs[i].time."
    - id: TIMELOCK-AGE
      rule: "Use tx.age >= period for relative timelocks (CSV)."
  canonical_absolute:
    shape: "require(tx.time >= timeoutTimestamp);"
    notes:
      - "tx.time is the block time. It is NOT tx.inputs[i].time — that field does not exist."
  canonical_relative:
    shape: "require(tx.age >= 30);"  # 30 blocks

escrow:
  rules:
    - id: ESCROW-BRANCH
      rule: "Escrow contracts must have a release branch (multi-party) and a reclaim branch (timeout)."
    - id: ESCROW-RECLAIM
      rule: "Reclaim branch must require both: (1) timeout check and (2) original sender signature."

  release_branch:
    must:
      - "Signature threshold logic (e.g. 2-of-3)"
      - "require(pk1 != pk2) distinctness checks for all signer pairs"
  reclaim_branch:
    must:
      - "require(tx.time >= timeoutTimestamp);"
      - "require(checkSig(reclaimerSig, originalSender));  // Reclaimer auth"
    canonical_shape: |
      function reclaim(sig reclaimerSig, int timeoutTimestamp) {
          require(tx.time >= timeoutTimestamp);
          require(checkSig(reclaimerSig, originalSender));
      }

general:
  - id: NO-FEE-ASSUMPTION
    rule: "Do not calculate miner fees via arithmetic (inputValue - outputValue). Use fixed output amounts."
  - id: NO-DIVISION-ZERO
    rule: "Before any division, require(divisor > 0) to prevent division-by-zero."
  - id: NO-TAUTOLOGY
    rule: "Do not write tautological guards like require(x == x). All guards must be meaningful."
  - id: NO-EMPTY-FUNCTION
    rule: "Every function body must contain at least one require() statement."
  - id: NO-HARDCODED-INDEX
    rule: "NEVER write require(this.activeInputIndex == 0). This is NOT a valid security guard."
    note: "this.activeInputIndex is for FIELD ACCESS only: tx.inputs[this.activeInputIndex].value"
    correct: "tx.inputs[this.activeInputIndex].lockingBytecode == this.activeBytecode"
    wrong:   "require(this.activeInputIndex == 0)  // FORBIDDEN"
  - id: VALUE-ANCHORING
    rule: "Every spending function MUST enforce exact output value: require(tx.outputs[0].value == tx.inputs[this.activeInputIndex].value)."
    note: "This prevents partial fund drain. No fee arithmetic — use a named 'fee' constructor param if needed."
  - id: OUTPUT-COUNT-STRICT
    rule: "Contracts that generate multiple outputs MUST explicitly validate tx.outputs.length before accessing any output index."
