# Synthesis rules — always injected. High-level structural patterns for contract generation.
# These are intent-level constraints with canonical code shapes to reduce LLM drift.

multisig:
  rules:
    - id: MULTISIG-DISTINCT-KEYS
      rule: "All pubkeys in a multisig MUST be distinct. Add require(pk1 != pk2) for every pair."
    - id: MULTISIG-DISTINCT-SIGS
      rule: "Use distinct signature variable names per signer (aliceSig, bobSig, carolSig)."
    - id: MULTISIG-THRESHOLD
      rule: "Implement threshold using integer accumulation of checkSig() results, not nested AND/OR chains."

  canonical_2_of_3:
    description: "Standard 2-of-3 multisig. Use checkMultiSig — no ternary, no accumulation variables."
    shape: |
      require(pk1 != pk2);
      require(pk1 != pk3);
      require(pk2 != pk3);
      require(checkMultiSig([sig1, sig2], [pk1, pk2, pk3]));
    notes:
      - "checkMultiSig([sigs], [pubkeys]) requires any 2 valid sigs from the 3 pubkeys."
      - "NEVER write: checkSig(...) ? 1 : 0  — ternary is FORBIDDEN in CashScript."
      - "NEVER accumulate with +=  — compound assignment is FORBIDDEN in CashScript."

  canonical_2_of_2:
    description: "Standard 2-of-2 multisig pattern with full output anchoring (value + lockingBytecode continuity)."
    shape: |
      require(pk1 != pk2);
      require(tx.outputs.length == 1);
      require(tx.outputs[0].lockingBytecode == tx.inputs[this.activeInputIndex].lockingBytecode);
      require(tx.outputs[0].value == tx.inputs[this.activeInputIndex].value);
      require(checkSig(sig1, pk1));
      require(checkSig(sig2, pk2));
    notes:
      - "Output count MUST be validated to prevent extra outputs draining funds."
      - "lockingBytecode continuity MUST be enforced to prevent output redirection attacks."
      - "Output value MUST equal input value — no implicit fee arithmetic."

  canonical_split_2party:
    description: "Canonical 2-party fund split. Pass expected recipient bytecodes as bytes20 constructor params. NO LockingBytecodeP2PKH() constructor calls."
    constructor_params: "bytes20 recipient1, bytes20 recipient2"
    shape: |
      require(checkSig(sig1, pk1));
      require(checkSig(sig2, pk2));
      require(tx.outputs.length == 2);

      // Recipient validation via constructor-injected bytecodes (no constructor call needed)
      require(tx.outputs[0].lockingBytecode == recipient1);
      require(tx.outputs[1].lockingBytecode == recipient2);

      // MANDATORY: Sum-preservation invariant — total output must equal input
      require(
          tx.outputs[0].value + tx.outputs[1].value ==
          tx.inputs[this.activeInputIndex].value
      );
    notes:
      - "NEVER call LockingBytecodeP2PKH(...) unless the bytes20 param is explicitly defined."
      - "Pass recipient1 and recipient2 as bytes20 constructor params — validates locking bytecode directly."
      - "Sum-preservation is NON-NEGOTIABLE — both values must sum to the input value."
      - "Do NOT use division for 50/50 split — use explicit value params or subtraction."
      - "No loops. No iteration over outputs."

timelock:
  rules:
    - id: TIMELOCK-GTE
      rule: "Use tx.time >= deadline for absolute timelocks (CLTV). NEVER use tx.inputs[i].time."
    - id: TIMELOCK-AGE
      rule: "Use tx.age >= period for relative timelocks (CSV)."
  canonical_absolute:
    shape: "require(tx.time >= timeoutTimestamp);"
    notes:
      - "tx.time is the block time. It is NOT tx.inputs[i].time — that field does not exist."
  canonical_relative:
    shape: "require(tx.age >= 30);"  # 30 blocks

escrow:
  rules:
    - id: ESCROW-BRANCH
      rule: "Escrow contracts must have a release branch (multi-party) and a reclaim branch (timeout)."
    - id: ESCROW-RECLAIM
      rule: "Reclaim branch must require both: (1) timeout check and (2) original sender signature."

  release_branch:
    must:
      - "Signature threshold logic (e.g. 2-of-3)"
      - "require(pk1 != pk2) distinctness checks for all signer pairs"
  reclaim_branch:
    must:
      - "require(tx.time >= timeoutTimestamp);"
      - "require(checkSig(reclaimerSig, originalSender));  // Reclaimer auth"
    canonical_shape: |
      function reclaim(sig reclaimerSig, int timeoutTimestamp) {
          require(tx.time >= timeoutTimestamp);
          require(checkSig(reclaimerSig, originalSender));
      }

general:
  - id: NO-FEE-ASSUMPTION
    rule: "Do not calculate miner fees via arithmetic (inputValue - outputValue). Use fixed output amounts."
  - id: NO-DIVISION-ZERO
    rule: "Before any division, require(divisor > 0) to prevent division-by-zero."
  - id: NO-TAUTOLOGY
    rule: "Do not write tautological guards like require(x == x). All guards must be meaningful."
  - id: NO-EMPTY-FUNCTION
    rule: "Every function body must contain at least one require() statement."
  - id: NO-HARDCODED-INDEX
    rule: "NEVER write require(this.activeInputIndex == 0). This is NOT a valid security guard."
    note: "this.activeInputIndex is for FIELD ACCESS only: tx.inputs[this.activeInputIndex].value"
    correct: "tx.inputs[this.activeInputIndex].lockingBytecode == this.activeBytecode"
    wrong:   "require(this.activeInputIndex == 0)  // FORBIDDEN"
  - id: VALUE-ANCHORING
    rule: "Every spending function MUST enforce exact output value: require(tx.outputs[0].value == tx.inputs[this.activeInputIndex].value)."
    note: "This prevents partial fund drain. No fee arithmetic — use a named 'fee' constructor param if needed."
  - id: OUTPUT-COUNT-STRICT
    rule: "Contracts that generate multiple outputs MUST explicitly validate tx.outputs.length before accessing any output index."

distribution:
  description: "Single-spend payout contracts. Funds exit the contract permanently. NO self-continuation."
  rules:
    - id: DISTRIBUTION-NO-SELF-ANCHOR
      rule: "Distribution contracts MUST NOT use this.activeBytecode. Funds are sent externally."
    - id: DISTRIBUTION-RECIPIENT
      rule: "Recipient MUST be a constructor param (bytes recipientLockingBytecode). Never hardcode."
    - id: DISTRIBUTION-VALUE
      rule: "MUST enforce require(tx.outputs[0].value == tx.inputs[this.activeInputIndex].value)."
    - id: DISTRIBUTION-OUTPUT-GUARD
      rule: "MUST enforce require(tx.outputs.length == 1) before accessing tx.outputs[0]."
    - id: DISTRIBUTION-AUTH
      rule: "MUST require owner signature: require(checkSig(ownerSig, owner))."

  canonical_payout:
    description: "Canonical single-spend payout. Owner authorizes, funds go to external recipient permanently."
    constructor_params: "pubkey owner, bytes recipientLockingBytecode"
    shape: |
      require(checkSig(ownerSig, owner));
      require(tx.outputs.length == 1);
      require(tx.outputs[0].lockingBytecode == recipientLockingBytecode);
      require(tx.outputs[0].value == tx.inputs[this.activeInputIndex].value);
    notes:
      - "Use bytes (not bytes20) for recipientLockingBytecode — supports P2PKH, P2SH20, P2SH32."
      - "DO NOT add this.activeBytecode — distribution contracts do NOT continue themselves."
      - "DO NOT subtract fees — pass full value to recipient."

  token_transfer:
    description: "Token payout / transfer. Preserves tokenCategory and tokenAmount to new recipient."
    constructor_params: "pubkey owner, bytes recipientLockingBytecode"
    shape: |
      require(checkSig(ownerSig, owner));
      require(tx.outputs.length == 1);
      require(tx.outputs[0].tokenCategory == tx.inputs[this.activeInputIndex].tokenCategory);
      require(tx.outputs[0].tokenAmount == tx.inputs[this.activeInputIndex].tokenAmount);
      require(tx.outputs[0].lockingBytecode == recipientLockingBytecode);
      require(tx.outputs[0].value == tx.inputs[this.activeInputIndex].value);
    notes:
      - "tokenCategory and tokenAmount MUST both be preserved unless explicitly minting/burning."
      - "DO NOT use this.activeBytecode — this is a distribution, not a covenant."
